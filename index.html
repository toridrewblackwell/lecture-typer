<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PIP-BOY LECTURE TYPER 3.0</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><circle cx='50' cy='50' r='40' fill='%2300ff88'/></svg>">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');
    
    :root {
      --green: #00ff88;
      --green-dim: #004422;
      --green-glow: rgba(0, 255, 136, 0.4);
      --red: #ff3333;
      --bg: #111;
    }
    
    * { box-sizing: border-box; }
    
    body {
      background-color: var(--bg);
      color: var(--green);
      font-family: 'Share Tech Mono', monospace;
      margin: 0;
      height: 100vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    body::before {
      content: " ";
      display: block;
      position: absolute;
      top: 0; left: 0; bottom: 0; right: 0;
      background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
      z-index: 2;
      background-size: 100% 2px, 3px 100%;
      pointer-events: none;
    }

    .pip-boy-frame {
      padding: 15px;
      height: 100%;
      display: flex;
      flex-direction: column;
      max-width: 1000px;
      margin: 0 auto;
      width: 100%;
      z-index: 1;
    }

    header {
      border-bottom: 2px solid var(--green);
      padding-bottom: 10px;
      margin-bottom: 15px;
      display: flex;
      justify-content: space-between;
      align-items: flex-end;
      text-shadow: 0 0 10px var(--green-glow);
    }

    h1 { margin: 0; font-size: 20px; letter-spacing: 2px; }
    .status { font-size: 12px; opacity: 0.8; }

    .stats-bar {
      display: flex;
      gap: 15px;
      margin-bottom: 15px;
      background: var(--green-dim);
      padding: 8px;
      border: 1px solid var(--green);
    }

    .stat { flex: 1; text-align: center; }
    .stat-val { font-size: 20px; font-weight: bold; }
    .stat-label { font-size: 10px; opacity: 0.7; }

    .typing-container {
      flex: 1;
      position: relative;
      background: #000;
      border: 2px solid var(--green);
      padding: 20px;
      font-size: 20px;
      line-height: 1.6;
      overflow-y: auto;
      cursor: text;
      box-shadow: inset 0 0 20px var(--green-glow);
      min-height: 200px;
    }

    .typing-content {
      white-space: pre-wrap;
      word-break: break-word;
      min-height: 100%;
      padding-bottom: 50vh;
    }

    .char { position: relative; }
    .char.correct { color: var(--green); text-shadow: 0 0 5px var(--green); }
    .char.incorrect { color: var(--red); text-decoration: underline; background: rgba(255,0,0,0.2); }
    .char.pending { color: var(--green); opacity: 0.3; }
    
    .char.current {
      background-color: var(--green);
      color: #000;
      animation: blink 1s infinite;
    }

    @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }

    #hidden-input {
      position: absolute;
      opacity: 0;
      pointer-events: none;
      top: -1000px;
    }

    .controls {
      margin-top: 15px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    button {
      background: transparent;
      border: 1px solid var(--green);
      color: var(--green);
      padding: 12px 20px;
      font-family: inherit;
      font-size: 14px;
      cursor: pointer;
      text-transform: uppercase;
      transition: all 0.2s;
      flex: 1;
      min-width: 120px;
    }

    button:hover, button:active { background: var(--green); color: #000; }
    button.active { background: var(--green); color: #000; box-shadow: 0 0 15px var(--green); }
    button.paste-btn { border-color: #ffaa00; color: #ffaa00; }
    button.paste-btn:hover, button.paste-btn:active { background: #ffaa00; color: #000; }
    
    .error-banner {
      color: var(--bg);
      background: var(--red);
      padding: 10px;
      margin-bottom: 10px;
      font-weight: bold;
    }
    
    .info-banner {
      font-size: 11px;
      margin-top: 10px;
      color: #ffaa00;
      border: 1px solid #ffaa00;
      padding: 8px;
      line-height: 1.4;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script type="text/babel">
    const { useState, useEffect, useRef, useCallback } = React;

    function App() {
      const [listening, setListening] = useState(false);
      const [fullText, setFullText] = useState(""); 
      const [typedIndex, setTypedIndex] = useState(0); 
      const [mistakes, setMistakes] = useState(new Set()); 
      const [wpm, setWpm] = useState(0);
      const [startTime, setStartTime] = useState(null);
      const [error, setError] = useState("");
      const [mode, setMode] = useState("paste"); // "mic" or "paste"
      
      const recognitionRef = useRef(null);
      const listeningRef = useRef(false);
      const inputRef = useRef(null);
      const containerRef = useRef(null);

      // Initialize speech recognition once
      useEffect(() => {
        if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
          return; // No mic support, paste mode only
        }

        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        const recognition = new SpeechRecognition();
        recognition.continuous = true;
        recognition.interimResults = true;
        recognition.lang = 'en-US';

        recognition.onresult = (event) => {
          let incomingFinal = '';
          for (let i = event.resultIndex; i < event.results.length; ++i) {
            if (event.results[i].isFinal) {
              incomingFinal += event.results[i][0].transcript;
            }
          }
          if (incomingFinal) {
            setFullText(prev => {
              let spacer = (prev.length > 0 && !prev.endsWith(' ')) ? ' ' : '';
              return prev + spacer + incomingFinal.trim();
            });
          }
        };

        recognition.onerror = (e) => {
          console.error('Speech recognition error:', e.error);
          if (e.error === 'not-allowed') {
            setError("Microphone blocked. Check permissions.");
            listeningRef.current = false;
            setListening(false);
          }
        };

        recognition.onend = () => {
          if (listeningRef.current) {
            try { recognition.start(); } catch(e) {}
          }
        };

        recognitionRef.current = recognition;

        return () => {
          recognition.stop();
        };
      }, []);

      const toggleListen = useCallback(() => {
        if (!recognitionRef.current) {
          setError("Speech recognition not supported in this browser.");
          return;
        }
        
        if (listening) {
          listeningRef.current = false;
          recognitionRef.current.stop();
          setListening(false);
        } else {
          setError("");
          listeningRef.current = true;
          try {
            recognitionRef.current.start();
            setListening(true);
            setMode("mic");
            inputRef.current?.focus();
          } catch(e) { 
            console.error(e);
            setError("Could not start microphone.");
          }
        }
      }, [listening]);

      const handlePaste = useCallback(async () => {
        try {
          const text = await navigator.clipboard.readText();
          if (text && text.trim()) {
            setFullText(prev => {
              if (prev.length === 0) return text.trim();
              return prev + ' ' + text.trim();
            });
            setMode("paste");
            inputRef.current?.focus();
          }
        } catch (e) {
          // Fallback: prompt user
          const text = prompt("Paste your transcript here:");
          if (text && text.trim()) {
            setFullText(prev => {
              if (prev.length === 0) return text.trim();
              return prev + ' ' + text.trim();
            });
            setMode("paste");
            inputRef.current?.focus();
          }
        }
      }, []);

      const handleKeyDown = useCallback((e) => {
        if (fullText.length === 0) return;
        if (typedIndex >= fullText.length) return;
        
        if (!startTime) setStartTime(Date.now());

        const targetChar = fullText[typedIndex];

        if (e.key === 'Backspace') {
          if (typedIndex > 0) {
            setTypedIndex(prev => prev - 1);
            setMistakes(prev => {
              const newMistakes = new Set(prev);
              newMistakes.delete(typedIndex - 1);
              return newMistakes;
            });
          }
          return;
        }

        if (e.key.length > 1) return; // Ignore special keys

        if (e.key === targetChar) {
          setTypedIndex(prev => prev + 1);
        } else {
          setMistakes(prev => new Set(prev).add(typedIndex));
          setTypedIndex(prev => prev + 1);
        }
        
        // Auto-scroll
        setTimeout(() => {
          const cursorEl = document.querySelector('.char.current');
          if (cursorEl) cursorEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }, 10);
      }, [fullText, typedIndex, startTime]);

      // WPM calculation
      useEffect(() => {
        if (!startTime || typedIndex === 0) return;
        const interval = setInterval(() => {
          const minutes = (Date.now() - startTime) / 60000;
          const words = typedIndex / 5;
          setWpm(Math.round(words / minutes));
        }, 1000);
        return () => clearInterval(interval);
      }, [startTime, typedIndex]);

      const clearAll = useCallback(() => {
        listeningRef.current = false;
        recognitionRef.current?.stop();
        setListening(false);
        setFullText("");
        setTypedIndex(0);
        setMistakes(new Set());
        setWpm(0);
        setStartTime(null);
        setError("");
        inputRef.current?.focus();
      }, []);

      // Keep input focused
      useEffect(() => {
        const handleClick = () => inputRef.current?.focus();
        document.addEventListener('click', handleClick);
        return () => document.removeEventListener('click', handleClick);
      }, []);

      const accuracy = typedIndex > 0 
        ? Math.round(((typedIndex - mistakes.size) / typedIndex) * 100) 
        : 100;

      return (
        <div className="pip-boy-frame">
          <header>
            <div>
              <h1>LECTURE TYPER v3.0</h1>
              <div className="status">MODE: {mode === "mic" ? "MICROPHONE" : "PASTE"}</div>
            </div>
            <div style={{textAlign:'right', fontSize: '12px'}}>
              {listening ? '‚óè LISTENING' : '‚óã STANDBY'}
            </div>
          </header>

          {error && <div className="error-banner">{error}</div>}

          <div className="stats-bar">
            <div className="stat">
              <div className="stat-val">{wpm}</div>
              <div className="stat-label">WPM</div>
            </div>
            <div className="stat">
              <div className="stat-val">{accuracy}%</div>
              <div className="stat-label">ACCURACY</div>
            </div>
            <div className="stat">
              <div className="stat-val">{Math.max(0, fullText.length - typedIndex)}</div>
              <div className="stat-label">REMAINING</div>
            </div>
          </div>

          <div 
            className="typing-container" 
            onClick={() => inputRef.current?.focus()}
            ref={containerRef}
          >
            <div className="typing-content">
              {fullText.length > 0 ? (
                fullText.split('').map((char, i) => {
                  let className = 'char';
                  if (i < typedIndex) {
                    className += mistakes.has(i) ? ' incorrect' : ' correct';
                  } else if (i === typedIndex) {
                    className += ' current';
                  } else {
                    className += ' pending';
                  }
                  return <span key={i} className={className}>{char}</span>;
                })
              ) : (
                <span className="char pending" style={{fontStyle:'italic'}}>
                  Tap PASTE to add text from Live Transcribe, or MIC to use browser transcription...
                </span>
              )}
              {typedIndex >= fullText.length && fullText.length > 0 && (
                <span style={{color: 'var(--green)', marginLeft: '10px'}}>‚úì COMPLETE</span>
              )}
            </div>
          </div>

          <input 
            id="hidden-input" 
            ref={inputRef} 
            type="text" 
            autoFocus 
            onKeyDown={handleKeyDown}
            autoComplete="off"
            autoCapitalize="off"
            autoCorrect="off"
            spellCheck="false"
          />

          <div className="controls">
            <button className="paste-btn" onClick={handlePaste}>
              üìã PASTE TEXT
            </button>
            <button 
              className={listening ? 'active' : ''} 
              onClick={toggleListen}
            >
              {listening ? '‚ñ† STOP MIC' : 'üé§ START MIC'}
            </button>
            <button onClick={clearAll}>‚Ü∫ RESET</button>
          </div>

          <div className="info-banner">
            <strong>TIP:</strong> For best results, use Google Live Transcribe app for transcription, 
            then copy the text and tap PASTE here to practice typing.
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
