<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PIP-BOY LECTURE TYPER 2.1</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><circle cx='50' cy='50' r='40' fill='%2300ff88'/></svg>">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');
    
    :root {
      --green: #00ff88;
      --green-dim: #004422;
      --green-glow: rgba(0, 255, 136, 0.4);
      --red: #ff3333;
      --bg: #111;
    }
    
    * { box-sizing: border-box; }
    
    body {
      background-color: var(--bg);
      color: var(--green);
      font-family: 'Share Tech Mono', monospace;
      margin: 0;
      height: 100vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    /* CRT Scanline Overlay */
    body::before {
      content: " ";
      display: block;
      position: absolute;
      top: 0; left: 0; bottom: 0; right: 0;
      background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
      z-index: 2;
      background-size: 100% 2px, 3px 100%;
      pointer-events: none;
    }

    .pip-boy-frame {
      padding: 20px;
      height: 100%;
      display: flex;
      flex-direction: column;
      max-width: 1000px;
      margin: 0 auto;
      width: 100%;
      z-index: 1;
    }

    header {
      border-bottom: 2px solid var(--green);
      padding-bottom: 10px;
      margin-bottom: 20px;
      display: flex;
      justify-content: space-between;
      align-items: flex-end;
      text-shadow: 0 0 10px var(--green-glow);
    }

    h1 { margin: 0; font-size: 24px; letter-spacing: 2px; }
    .status { font-size: 14px; opacity: 0.8; }

    .stats-bar {
      display: flex;
      gap: 20px;
      margin-bottom: 20px;
      background: var(--green-dim);
      padding: 10px;
      border: 1px solid var(--green);
    }

    .stat { flex: 1; text-align: center; }
    .stat-val { font-size: 24px; font-weight: bold; }
    .stat-label { font-size: 12px; opacity: 0.7; }

    /* TYPING AREA */
    .typing-container {
      flex: 1;
      position: relative;
      background: #000;
      border: 2px solid var(--green);
      padding: 30px;
      font-size: 24px;
      line-height: 1.6;
      overflow-y: auto;
      cursor: text;
      box-shadow: inset 0 0 20px var(--green-glow);
    }

    .typing-content {
      white-space: pre-wrap;
      word-break: break-word;
      min-height: 100%;
      padding-bottom: 50vh; /* Allows scrolling past end */
    }

    .char { position: relative; }
    .char.correct { color: var(--green); text-shadow: 0 0 5px var(--green); }
    .char.incorrect { color: var(--red); text-decoration: underline; background: rgba(255,0,0,0.2); }
    .char.pending { color: var(--green); opacity: 0.3; }
    
    .char.current {
      background-color: var(--green);
      color: #000;
      animation: blink 1s infinite;
    }

    @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }

    #hidden-input {
      position: absolute;
      opacity: 0;
      top: -1000px;
    }

    .controls {
      margin-top: 20px;
      display: flex;
      gap: 10px;
    }

    button {
      background: transparent;
      border: 1px solid var(--green);
      color: var(--green);
      padding: 10px 20px;
      font-family: inherit;
      font-size: 16px;
      cursor: pointer;
      text-transform: uppercase;
      transition: all 0.2s;
    }

    button:hover { background: var(--green); color: #000; }
    button.active { background: var(--green); color: #000; box-shadow: 0 0 15px var(--green); }
    
    .error-banner {
      color: var(--bg);
      background: var(--red);
      padding: 10px;
      margin-bottom: 10px;
      font-weight: bold;
      display: none;
    }
    
    .mic-warning {
      font-size: 12px;
      margin-top: 10px;
      color: #ffaa00;
      border: 1px solid #ffaa00;
      padding: 10px;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    function App() {
      const [listening, setListening] = useState(false);
      const [fullText, setFullText] = useState(""); 
      const [typedIndex, setTypedIndex] = useState(0); 
      const [mistakes, setMistakes] = useState(new Set()); 
      const [wpm, setWpm] = useState(0);
      const [startTime, setStartTime] = useState(null);
      const [browserError, setBrowserError] = useState("");
      
      const recognitionRef = useRef(null);
      const inputRef = useRef(null);
      const containerRef = useRef(null);

      useEffect(() => {
        if (!('webkitSpeechRecognition' in window)) {
          setBrowserError("CRITICAL ERROR: Browser not supported. Use Chrome, Edge, or Brave.");
          return;
        }

        const recognition = new window.webkitSpeechRecognition();
        recognition.continuous = true;
        recognition.interimResults = true;
        recognition.lang = 'en-US';

        recognition.onresult = (event) => {
          let incomingFinal = '';
          for (let i = event.resultIndex; i < event.results.length; ++i) {
            if (event.results[i].isFinal) {
              incomingFinal += event.results[i][0].transcript;
            }
          }
          if (incomingFinal) {
            setFullText(prev => {
              let spacer = (prev.length > 0 && !prev.endsWith(' ')) ? ' ' : '';
              return prev + spacer + incomingFinal.trim();
            });
          }
        };

        recognition.onerror = (e) => {
          if (e.error === 'not-allowed') {
            setListening(false);
            alert("Microphone access blocked. Check permissions or HTTPS.");
          }
        };

        recognition.onend = () => {
          if (listening) {
            try { recognition.start(); } catch(e){}
          }
        };

        recognitionRef.current = recognition;
      }, [listening]);

      const toggleListen = () => {
        if (browserError) return;
        if (listening) {
          recognitionRef.current?.stop();
          setListening(false);
        } else {
          try {
            recognitionRef.current?.start();
            setListening(true);
            inputRef.current?.focus();
          } catch(e) { console.error(e); }
        }
      };

      const handleKeyDown = (e) => {
        // Prevent default spacebar scrolling
        if (e.key === ' ' && e.target === inputRef.current) {
            // No preventDefault needed for space in text input, 
            // but good to keep focus logic clean.
        }

        if (!listening && fullText.length === 0) return;
        if (!startTime) setStartTime(Date.now());

        const targetChar = fullText[typedIndex];

        if (e.key === 'Backspace') {
          if (typedIndex > 0) {
            setTypedIndex(prev => prev - 1);
            setMistakes(prev => {
              const newMistakes = new Set(prev);
              newMistakes.delete(typedIndex - 1);
              return newMistakes;
            });
          }
          return;
        }

        if (e.key.length > 1) return;

        if (e.key === targetChar) {
          setTypedIndex(prev => prev + 1);
        } else {
          setMistakes(prev => new Set(prev).add(typedIndex));
          setTypedIndex(prev => prev + 1);
        }
        
        // Auto-scroll logic
        setTimeout(() => {
          const cursorEl = document.querySelector('.char.current');
          if (cursorEl) cursorEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }, 10);
      };

      // WPM Timer
      useEffect(() => {
        if (!startTime || typedIndex === 0) return;
        const interval = setInterval(() => {
          const minutes = (Date.now() - startTime) / 60000;
          const words = typedIndex / 5;
          setWpm(Math.round(words / minutes));
        }, 1000);
        return () => clearInterval(interval);
      }, [startTime, typedIndex]);

      const clearAll = () => {
        setFullText("");
        setTypedIndex(0);
        setMistakes(new Set());
        setWpm(0);
        setStartTime(null);
        inputRef.current?.focus();
      };

      return (
        <div className="pip-boy-frame">
          <header>
            <div>
              <h1>LECTURE TYPER v2.1</h1>
              <div className="status">OS: PIP-BOY 3000 // MEMORY: OK</div>
            </div>
            <div style={{textAlign:'right'}}>
              STATUS: {listening ? 'RECEIVING AUDIO...' : 'STANDBY'}
            </div>
          </header>

          {browserError && <div className="error-banner" style={{display:'block'}}>{browserError}</div>}

          <div className="stats-bar">
            <div className="stat">
              <div className="stat-val">{wpm}</div>
              <div className="stat-label">WPM</div>
            </div>
            <div className="stat">
              <div className="stat-val">
                {typedIndex > 0 
                  ? Math.round(((typedIndex - mistakes.size) / typedIndex) * 100) 
                  : 100}%
              </div>
              <div className="stat-label">ACCURACY</div>
            </div>
            <div className="stat">
              <div className="stat-val">{fullText.length - typedIndex}</div>
              <div className="stat-label">BUFFER</div>
            </div>
          </div>

          <div 
            className="typing-container" 
            onClick={() => inputRef.current?.focus()}
            ref={containerRef}
          >
            <div className="typing-content">
              {fullText.split('').map((char, i) => {
                let className = 'char';
                if (i < typedIndex) {
                  className += mistakes.has(i) ? ' incorrect' : ' correct';
                } else if (i === typedIndex) {
                  className += ' current';
                } else {
                  className += ' pending';
                }
                return <span key={i} className={className}>{char}</span>;
              })}
              {fullText.length === 0 && (
                <span className="char pending" style={{fontStyle:'italic'}}>
                  {listening ? "Waiting for audio input..." : "Press START to begin listening..."}
                </span>
              )}
            </div>
          </div>

          <input 
            id="hidden-input" 
            ref={inputRef} 
            type="text" 
            autoFocus 
            onKeyDown={handleKeyDown}
            autoComplete="off"
          />

          <div className="mic-warning">
            <strong>⚠ SETUP REQUIRED:</strong> To transcribe computer audio, you MUST install 
            <strong> VB-Cable</strong> and route audio through it. 
            <br/>If you just use your microphone, this app will not work well.
          </div>

          <div className="controls">
            <button 
              className={listening ? 'active' : ''} 
              onClick={toggleListen}
            >
              {listening ? '■ STOP RECEIVER' : '▶ START RECEIVER'}
            </button>
            <button onClick={clearAll}>RESET DATA</button>
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
